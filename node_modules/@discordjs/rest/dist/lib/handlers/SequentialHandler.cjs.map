{"version":3,"file":"SequentialHandler.cjs","sources":["../../../src/lib/handlers/SequentialHandler.ts"],"sourcesContent":["import { setTimeout as sleep } from 'node:timers/promises';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport { request, type Dispatcher } from 'undici';\nimport type { IHandler } from './IHandler';\nimport type { RateLimitData, RequestOptions } from '../REST';\nimport type { HandlerRequestData, RequestManager, RouteData } from '../RequestManager';\nimport { DiscordAPIError, DiscordErrorData, OAuthErrorData } from '../errors/DiscordAPIError';\nimport { HTTPError } from '../errors/HTTPError';\nimport { RateLimitError } from '../errors/RateLimitError';\nimport { RESTEvents } from '../utils/constants';\nimport { hasSublimit, parseHeader, parseResponse } from '../utils/utils';\n\n/**\n * Invalid request limiting is done on a per-IP basis, not a per-token basis.\n * The best we can do is track invalid counts process-wide (on the theory that\n * users could have multiple bots run from one process) rather than per-bot.\n * Therefore, store these at file scope here rather than in the client's\n * RESTManager object.\n */\nlet invalidCount = 0;\nlet invalidCountResetTime: number | null = null;\n\nconst enum QueueType {\n\tStandard,\n\tSublimit,\n}\n\n/**\n * The structure used to handle requests for a given bucket\n */\nexport class SequentialHandler implements IHandler {\n\t/**\n\t * The unique id of the handler\n\t */\n\tpublic readonly id: string;\n\n\t/**\n\t * The time this rate limit bucket will reset\n\t */\n\tprivate reset = -1;\n\n\t/**\n\t * The remaining requests that can be made before we are rate limited\n\t */\n\tprivate remaining = 1;\n\n\t/**\n\t * The total number of requests that can be made before we are rate limited\n\t */\n\tprivate limit = Infinity;\n\n\t/**\n\t * The interface used to sequence async requests sequentially\n\t */\n\t// eslint-disable-next-line @typescript-eslint/explicit-member-accessibility\n\t#asyncQueue = new AsyncQueue();\n\n\t/**\n\t * The interface used to sequence sublimited async requests sequentially\n\t */\n\t// eslint-disable-next-line @typescript-eslint/explicit-member-accessibility\n\t#sublimitedQueue: AsyncQueue | null = null;\n\n\t/**\n\t * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed\n\t */\n\t// eslint-disable-next-line @typescript-eslint/explicit-member-accessibility\n\t#sublimitPromise: { promise: Promise<void>; resolve: () => void } | null = null;\n\n\t/**\n\t * Whether the sublimit queue needs to be shifted in the finally block\n\t */\n\t// eslint-disable-next-line @typescript-eslint/explicit-member-accessibility\n\t#shiftSublimit = false;\n\n\t/**\n\t * @param manager - The request manager\n\t * @param hash - The hash that this RequestHandler handles\n\t * @param majorParameter - The major parameter for this handler\n\t */\n\tpublic constructor(\n\t\tprivate readonly manager: RequestManager,\n\t\tprivate readonly hash: string,\n\t\tprivate readonly majorParameter: string,\n\t) {\n\t\tthis.id = `${hash}:${majorParameter}`;\n\t}\n\n\t/**\n\t * If the bucket is currently inactive (no pending requests)\n\t */\n\tpublic get inactive(): boolean {\n\t\treturn (\n\t\t\tthis.#asyncQueue.remaining === 0 &&\n\t\t\t(this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) &&\n\t\t\t!this.limited\n\t\t);\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by the global limit\n\t */\n\tprivate get globalLimited(): boolean {\n\t\treturn this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by its limit\n\t */\n\tprivate get localLimited(): boolean {\n\t\treturn this.remaining <= 0 && Date.now() < this.reset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited\n\t */\n\tprivate get limited(): boolean {\n\t\treturn this.globalLimited || this.localLimited;\n\t}\n\n\t/**\n\t * The time until queued requests can continue\n\t */\n\tprivate get timeToReset(): number {\n\t\treturn this.reset + this.manager.options.offset - Date.now();\n\t}\n\n\t/**\n\t * Emits a debug message\n\t *\n\t * @param message - The message to debug\n\t */\n\tprivate debug(message: string) {\n\t\tthis.manager.emit(RESTEvents.Debug, `[REST ${this.id}] ${message}`);\n\t}\n\n\t/**\n\t * Delay all requests for the specified amount of time, handling global rate limits\n\t *\n\t * @param time - The amount of time to delay all requests for\n\t */\n\tprivate async globalDelayFor(time: number): Promise<void> {\n\t\tawait sleep(time, undefined, { ref: false });\n\t\tthis.manager.globalDelay = null;\n\t}\n\n\t/*\n\t * Determines whether the request should be queued or whether a RateLimitError should be thrown\n\t */\n\tprivate async onRateLimit(rateLimitData: RateLimitData) {\n\t\tconst { options } = this.manager;\n\t\tif (!options.rejectOnRateLimit) return;\n\n\t\tconst shouldThrow =\n\t\t\ttypeof options.rejectOnRateLimit === 'function'\n\t\t\t\t? await options.rejectOnRateLimit(rateLimitData)\n\t\t\t\t: options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));\n\t\tif (shouldThrow) {\n\t\t\tthrow new RateLimitError(rateLimitData);\n\t\t}\n\t}\n\n\t/**\n\t * Queues a request to be sent\n\t *\n\t * @param routeId - The generalized api route with literal ids for major parameters\n\t * @param url - The url to do the request on\n\t * @param options - All the information needed to make a request\n\t * @param requestData - Extra data from the user's request needed for errors and additional processing\n\t */\n\tpublic async queueRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t): Promise<Dispatcher.ResponseData> {\n\t\tlet queue = this.#asyncQueue;\n\t\tlet queueType = QueueType.Standard;\n\t\t// Separate sublimited requests when already sublimited\n\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\tqueueType = QueueType.Sublimit;\n\t\t}\n\t\t// Wait for any previous requests to be completed before this one is run\n\t\tawait queue.wait();\n\t\t// This set handles retroactively sublimiting requests\n\t\tif (queueType === QueueType.Standard) {\n\t\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\t\t/**\n\t\t\t\t * Remove the request from the standard queue, it should never be possible to get here while processing the\n\t\t\t\t * sublimit queue so there is no need to worry about shifting the wrong request\n\t\t\t\t */\n\t\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\t\tconst wait = queue.wait();\n\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\tawait wait;\n\t\t\t} else if (this.#sublimitPromise) {\n\t\t\t\t// Stall requests while the sublimit queue gets processed\n\t\t\t\tawait this.#sublimitPromise.promise;\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\t// Make the request, and return the results\n\t\t\treturn await this.runRequest(routeId, url, options, requestData);\n\t\t} finally {\n\t\t\t// Allow the next request to fire\n\t\t\tqueue.shift();\n\t\t\tif (this.#shiftSublimit) {\n\t\t\t\tthis.#shiftSublimit = false;\n\t\t\t\tthis.#sublimitedQueue?.shift();\n\t\t\t}\n\t\t\t// If this request is the last request in a sublimit\n\t\t\tif (this.#sublimitedQueue?.remaining === 0) {\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitedQueue = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The method that actually makes the request to the api, and updates info about the bucket accordingly\n\t *\n\t * @param routeId - The generalized api route with literal ids for major parameters\n\t * @param url - The fully resolved url to make the request to\n\t * @param options - The fetch options needed to make the request\n\t * @param requestData - Extra data from the user's request needed for errors and additional processing\n\t * @param retries - The number of retries this request has already attempted (recursion)\n\t */\n\tprivate async runRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t\tretries = 0,\n\t): Promise<Dispatcher.ResponseData> {\n\t\t/*\n\t\t * After calculations have been done, pre-emptively stop further requests\n\t\t * Potentially loop until this task can run if e.g. the global rate limit is hit twice\n\t\t */\n\t\twhile (this.limited) {\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\t\t\tlet delay: Promise<void>;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t\t// If this is the first task to reach the global timeout, set the global delay\n\t\t\t\tif (!this.manager.globalDelay) {\n\t\t\t\t\t// The global delay function clears the global delay state when it is resolved\n\t\t\t\t\tthis.manager.globalDelay = this.globalDelayFor(timeout);\n\t\t\t\t}\n\t\t\t\tdelay = this.manager.globalDelay;\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t\tdelay = sleep(timeout);\n\t\t\t}\n\t\t\tconst rateLimitData: RateLimitData = {\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod: options.method ?? 'get',\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t};\n\t\t\t// Let library users know they have hit a rate limit\n\t\t\tthis.manager.emit(RESTEvents.RateLimited, rateLimitData);\n\t\t\t// Determine whether a RateLimitError should be thrown\n\t\t\tawait this.onRateLimit(rateLimitData);\n\t\t\t// When not erroring, emit debug for what is happening\n\t\t\tif (isGlobal) {\n\t\t\t\tthis.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);\n\t\t\t} else {\n\t\t\t\tthis.debug(`Waiting ${timeout}ms for rate limit to pass`);\n\t\t\t}\n\t\t\t// Wait the remaining time left before the rate limit resets\n\t\t\tawait delay;\n\t\t}\n\t\t// As the request goes out, update the global usage information\n\t\tif (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n\t\t\tthis.manager.globalReset = Date.now() + 1000;\n\t\t\tthis.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;\n\t\t}\n\t\tthis.manager.globalRemaining--;\n\n\t\tconst method = options.method ?? 'get';\n\n\t\tconst controller = new AbortController();\n\t\tconst timeout = setTimeout(() => controller.abort(), this.manager.options.timeout).unref();\n\t\tlet res: Dispatcher.ResponseData;\n\n\t\ttry {\n\t\t\tres = await request(url, { ...options, signal: controller.signal });\n\t\t} catch (error: unknown) {\n\t\t\t// Retry the specified number of times for possible timed out requests\n\t\t\tif (error instanceof Error && error.name === 'AbortError' && retries !== this.manager.options.retries) {\n\t\t\t\treturn await this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\n\t\tif (this.manager.listenerCount(RESTEvents.Response)) {\n\t\t\tthis.manager.emit(\n\t\t\t\tRESTEvents.Response,\n\t\t\t\t{\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath: routeId.original,\n\t\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\t\toptions,\n\t\t\t\t\tdata: requestData,\n\t\t\t\t\tretries,\n\t\t\t\t},\n\t\t\t\t{ ...res },\n\t\t\t);\n\t\t}\n\n\t\tconst status = res.statusCode;\n\t\tlet retryAfter = 0;\n\n\t\tconst limit = parseHeader(res.headers['x-ratelimit-limit']);\n\t\tconst remaining = parseHeader(res.headers['x-ratelimit-remaining']);\n\t\tconst reset = parseHeader(res.headers['x-ratelimit-reset-after']);\n\t\tconst hash = parseHeader(res.headers['x-ratelimit-bucket']);\n\t\tconst retry = parseHeader(res.headers['retry-after']);\n\n\t\t// Update the total number of requests that can be made before the rate limit resets\n\t\tthis.limit = limit ? Number(limit) : Infinity;\n\t\t// Update the number of remaining requests that can be made before the rate limit resets\n\t\tthis.remaining = remaining ? Number(remaining) : 1;\n\t\t// Update the time when this rate limit resets (reset-after is in seconds)\n\t\tthis.reset = reset ? Number(reset) * 1000 + Date.now() + this.manager.options.offset : Date.now();\n\n\t\t// Amount of time in milliseconds until we should retry if rate limited (globally or otherwise)\n\t\tif (retry) retryAfter = Number(retry) * 1000 + this.manager.options.offset;\n\n\t\t// Handle buckets via the hash header retroactively\n\t\tif (hash && hash !== this.hash) {\n\t\t\t// Let library users know when rate limit buckets have been updated\n\t\t\tthis.debug(['Received bucket hash update', `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join('\\n'));\n\t\t\t// This queue will eventually be eliminated via attrition\n\t\t\tthis.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });\n\t\t} else if (hash) {\n\t\t\t// Handle the case where hash value doesn't change\n\t\t\t// Fetch the hash data from the manager\n\t\t\tconst hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);\n\n\t\t\t// When fetched, update the last access of the hash\n\t\t\tif (hashData) {\n\t\t\t\thashData.lastAccess = Date.now();\n\t\t\t}\n\t\t}\n\n\t\t// Handle retryAfter, which means we have actually hit a rate limit\n\t\tlet sublimitTimeout: number | null = null;\n\t\tif (retryAfter > 0) {\n\t\t\tif (res.headers['x-ratelimit-global'] !== undefined) {\n\t\t\t\tthis.manager.globalRemaining = 0;\n\t\t\t\tthis.manager.globalReset = Date.now() + retryAfter;\n\t\t\t} else if (!this.localLimited) {\n\t\t\t\t/*\n\t\t\t\t * This is a sublimit (e.g. 2 channel name changes/10 minutes) since the headers don't indicate a\n\t\t\t\t * route-wide rate limit. Don't update remaining or reset to avoid rate limiting the whole\n\t\t\t\t * endpoint, just set a reset time on the request itself to avoid retrying too soon.\n\t\t\t\t */\n\t\t\t\tsublimitTimeout = retryAfter;\n\t\t\t}\n\t\t}\n\n\t\t// Count the invalid requests\n\t\tif (status === 401 || status === 403 || status === 429) {\n\t\t\tif (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n\t\t\t\tinvalidCountResetTime = Date.now() + 1000 * 60 * 10;\n\t\t\t\tinvalidCount = 0;\n\t\t\t}\n\t\t\tinvalidCount++;\n\n\t\t\tconst emitInvalid =\n\t\t\t\tthis.manager.options.invalidRequestWarningInterval > 0 &&\n\t\t\t\tinvalidCount % this.manager.options.invalidRequestWarningInterval === 0;\n\t\t\tif (emitInvalid) {\n\t\t\t\t// Let library users know periodically about invalid requests\n\t\t\t\tthis.manager.emit(RESTEvents.InvalidRequestWarning, {\n\t\t\t\t\tcount: invalidCount,\n\t\t\t\t\tremainingTime: invalidCountResetTime - Date.now(),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (status >= 200 && status < 300) {\n\t\t\treturn res;\n\t\t} else if (status === 429) {\n\t\t\t// A rate limit was hit - this may happen if the route isn't associated with an official bucket hash yet, or when first globally rate limited\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t}\n\t\t\tawait this.onRateLimit({\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod,\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t});\n\t\t\tthis.debug(\n\t\t\t\t[\n\t\t\t\t\t'Encountered unexpected 429 rate limit',\n\t\t\t\t\t`  Global         : ${isGlobal.toString()}`,\n\t\t\t\t\t`  Method         : ${method}`,\n\t\t\t\t\t`  URL            : ${url}`,\n\t\t\t\t\t`  Bucket         : ${routeId.bucketRoute}`,\n\t\t\t\t\t`  Major parameter: ${routeId.majorParameter}`,\n\t\t\t\t\t`  Hash           : ${this.hash}`,\n\t\t\t\t\t`  Limit          : ${limit}`,\n\t\t\t\t\t`  Retry After    : ${retryAfter}ms`,\n\t\t\t\t\t`  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : 'None'}`,\n\t\t\t\t].join('\\n'),\n\t\t\t);\n\t\t\t// If caused by a sublimit, wait it out here so other requests on the route can be handled\n\t\t\tif (sublimitTimeout) {\n\t\t\t\t// Normally the sublimit queue will not exist, however, if a sublimit is hit while in the sublimit queue, it will\n\t\t\t\tconst firstSublimit = !this.#sublimitedQueue;\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\tthis.#sublimitedQueue = new AsyncQueue();\n\t\t\t\t\tvoid this.#sublimitedQueue.wait();\n\t\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\t}\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitPromise = null;\n\t\t\t\tawait sleep(sublimitTimeout, undefined, { ref: false });\n\t\t\t\tlet resolve: () => void;\n\t\t\t\tconst promise = new Promise<void>((res) => (resolve = res));\n\t\t\t\tthis.#sublimitPromise = { promise, resolve: resolve! };\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\t// Re-queue this request so it can be shifted by the finally\n\t\t\t\t\tawait this.#asyncQueue.wait();\n\t\t\t\t\tthis.#shiftSublimit = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Since this is not a server side issue, the next request should pass, so we don't bump the retries counter\n\t\t\treturn this.runRequest(routeId, url, options, requestData, retries);\n\t\t} else if (status >= 500 && status < 600) {\n\t\t\t// Retry the specified number of times for possible server side issues\n\t\t\tif (retries !== this.manager.options.retries) {\n\t\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\t\t\t// We are out of retries, throw an error\n\t\t\tthrow new HTTPError(res.constructor.name, status, method, url, requestData);\n\t\t} else {\n\t\t\t// Handle possible malformed requests\n\t\t\tif (status >= 400 && status < 500) {\n\t\t\t\t// If we receive this status code, it means the token we had is no longer valid.\n\t\t\t\tif (status === 401 && requestData.auth) {\n\t\t\t\t\tthis.manager.setToken(null!);\n\t\t\t\t}\n\t\t\t\t// The request will not succeed for some reason, parse the error returned from the api\n\t\t\t\tconst data = (await parseResponse(res)) as DiscordErrorData | OAuthErrorData;\n\t\t\t\t// throw the API error\n\t\t\t\tthrow new DiscordAPIError(data, 'code' in data ? data.code : data.error, status, method, url, requestData);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n}\n"],"names":["AsyncQueue","RESTEvents","sleep","RateLimitError","hasSublimit","request","parseHeader","HTTPError","parseResponse","DiscordAPIError"],"mappings":"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"}